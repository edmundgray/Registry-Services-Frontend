<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
        <link rel="stylesheet" href="../CSS/style.css">
        
        <!-- Add authManager.js for global AuthManager and AUTH_CONFIG -->
        <script src="../JS/auth/authManager.js"></script>
        <script>
            // Create a global authManager instance
            window.authManager = new AuthManager();
            // Define authenticatedFetch globally
            function authenticatedFetch(url, options = {}) {
                const headers = { ...(options.headers || {}), ...window.authManager.getAuthHeaders() };
                return fetch(url, { ...options, headers });
            }
        </script>
        <script src="../JS/sidebarManager.js"></script>
        <script src="../JS/javascript.js"></script>
        <script src="../JS/dataManager.js"></script>
        
        <title>Registry Services</title>
        <style>
            .component-section {
                border: 1px solid #ddd;
                padding: 15px;
                margin-bottom: 20px;
                background-color: #fff;
                border-radius: 5px;
            }
        </style>
    </head>
    <body>
        <div id="sidebarContainer">
            <!-- Sidebar will be dynamically generated by sidebarManager.js -->
        </div>

        <div class="page-Content">
            <h1><i class="fa-solid fa-trailer"></i> Extension Component Data Model</h1>
            <br/>
            
            <div id="components-container"></div>

            <button type="button" onclick="addNewComponentSection()" class="view-button" style="margin-top: 15px;">Add Another Extension Component</button>

            <hr style="margin: 30px 0;">

            <div style="display: flex; justify-content: space-between; gap: 10px; margin-top: 10px;">
                <div>
                    <button type="button" onclick="handleSave()" class="view-button" style="background:#ccc; color:#333;">Save</button>
                    <button type="button" onclick="handleCancel()" class="view-button" style="background-color: #F4A261; color: #fff;">Cancel</button>
                </div>
                <div>
                    <button type="button" onclick="saveAndGoToNextStep()" class="view-button" style="background:#217a36;">Additional Requirements</button>
                </div>
            </div>
        </div>

        <script>
            let isFormDirty = false;
            let dataManager = null;
            // Cache for storing fetched extension component elements to avoid re-fetching
            let extensionComponentElementsCache = {}; // Changed from extensionComponentData
            let componentsContainer;

            // Initialize data manager
            async function initializeDataManager() {
                try {
                    console.log('DEBUG: ExtensionComponentDataModel - Initializing data manager');
                    console.log('DEBUG: ExtensionComponentDataModel - LocalStorage state:');
                    console.log('  - editMode:', localStorage.getItem('editMode'));
                    console.log('  - specificationIdentityId:', localStorage.getItem('specificationIdentityId'));
                    
                    dataManager = new SpecificationDataManager();
                    console.log('DEBUG: ExtensionComponentDataModel - Data manager initialized');
                    console.log('DEBUG: ExtensionComponentDataModel - Mode:', dataManager.currentMode);
                    console.log('DEBUG: ExtensionComponentDataModel - isEditMode():', dataManager.isEditMode());
                    
                    if (dataManager.isEditMode() && dataManager.currentSpecId) {
                        console.log('DEBUG: ExtensionComponentDataModel - Loading specification for editing. ID:', dataManager.currentSpecId);
                        
                        // Load data from API if not already loaded
                        if (!dataManager.isDataLoaded) {
                            await dataManager.loadSpecificationFromAPI(dataManager.currentSpecId);
                        }
                        
                        // Get the working data (should include extensionComponentData)
                        const workingData = dataManager.workingData || dataManager.loadWorkingDataFromLocalStorage();
                        console.log('DEBUG: ExtensionComponentDataModel - Working data:', workingData);
                        
                        if (workingData && workingData.extensionComponentData) {
                            console.log('DEBUG: ExtensionComponentDataModel - Found extension component data:', workingData.extensionComponentData);
                            return workingData.extensionComponentData;
                        }
                    } else {
                        console.log('DEBUG: ExtensionComponentDataModel - Creating new specification or missing spec ID');
                        // For new specifications, check if there's any working data
                        const workingData = dataManager.loadWorkingDataFromLocalStorage();
                        if (workingData && workingData.extensionComponentData) {
                            console.log('DEBUG: ExtensionComponentDataModel - Found working extension data');
                            return workingData.extensionComponentData;
                        }
                    }
                    
                    console.log('DEBUG: ExtensionComponentDataModel - No existing extension data found');
                    return [];
                } catch (error) {
                    console.error('DEBUG: ExtensionComponentDataModel - Error initializing data manager:', error);
                    throw error;
                }
            }

            async function loadExtensionData() {
                try {
                    // Initialize data manager first
                    const savedExtensions = await initializeDataManager();
                    
                    // Fetch the list of available Extension Components (headers)
                    // Assuming /api/extensionmodels/headers provides a list of {id, name} objects
                    const headersApiUrl = `${AUTH_CONFIG.baseUrl}/extensionmodels/headers?page=1&pageSize=50`; // Adjust page size as needed

                    console.log(`Attempting to fetch Extension Component Headers from API: ${headersApiUrl}`);
                    const headersResponse = await authenticatedFetch(headersApiUrl, {
                        method: 'GET',
                        forceAuth: true // Assuming this endpoint also requires authentication
                    });

                    if (!headersResponse.ok) {
                        throw new Error(`HTTP error! status: ${headersResponse.status}`);
                    }
                    const headersData = await headersResponse.json();
                    const availableComponents = headersData.items || headersData; // Assuming it returns {items: []} or directly an array
                    console.log('Available Extension Component Headers:', availableComponents);

                    // Populate the dropdown with available components
                    const initialSectionSelect = document.querySelector('.component-section .component-select');
                    if (initialSectionSelect) {
                        let options = '<option value="">Select an Extension Component</option>';
                        availableComponents.forEach(comp => {
                            options += `<option value="${comp.id}">${comp.name || comp.id}</option>`; // Use comp.name if available, else comp.id
                        });
                        initialSectionSelect.innerHTML = options;
                    }

                    // Use saved extensions from data manager instead of localStorage
                    if (savedExtensions && savedExtensions.length > 0) {
                        console.log('DEBUG: ExtensionComponentDataModel - Loading saved extensions:', savedExtensions);
                        // For each saved extension, add a section and populate its table
                        for (const savedExt of savedExtensions) {
                            await addNewComponentSection(savedExt.componentName, savedExt.selectedElements);
                        }
                        // Remove the initial empty section if more than one saved extension was added
                        if (savedExtensions.length > 0 && document.querySelectorAll('.component-section').length > 1) {
                            document.querySelector('.component-section:first-child').remove();
                        }
                    } else {
                        // If no saved extensions, ensure at least one empty section is present
                        if (document.querySelectorAll('.component-section').length === 0) {
                            addNewComponentSection();
                        }
                    }

                } catch (error) {
                    console.error("Error loading extension component data:", error);
                    if (componentsContainer) {
                         componentsContainer.innerHTML = `<p style="color: red;">Error: Could not load extension component data. Please ensure you are logged in and the API is accessible.</p>`;
                    }
                }
            }

            // addNewComponentSection now takes an optional preSelectedComponentId and preSelectedElementIds
            async function addNewComponentSection(preSelectedComponentId = '', preSelectedElementIds = []) {
                const sectionId = `section-${Date.now()}`;
                const section = document.createElement('div');
                section.className = 'component-section';
                section.id = sectionId;

                // Fetch the list of all components again to populate the new dropdown
                const headersApiUrl = `${AUTH_CONFIG.baseUrl}/extensionmodels/headers?page=1&pageSize=50`;
                let availableComponents = [];
                try {
                    const headersResponse = await authenticatedFetch(headersApiUrl, { method: 'GET', forceAuth: true });
                    const headersData = await headersResponse.json();
                    availableComponents = headersData.items || headersData;
                } catch (error) {
                    console.error("Error re-fetching component headers for new section:", error);
                }

                let options = '<option value="">Select an Extension Component</option>';
                availableComponents.forEach(comp => {
                    options += `<option value="${comp.id}" ${comp.id === preSelectedComponentId ? 'selected' : ''}>${comp.name || comp.id}</option>`;
                });


                section.innerHTML = `
                    <select class="component-select" onchange="populateComponentTable(this, [])">${options}</select>
                    <p style="margin-top: 5px;">Select the required Extension Component and tick the box for all required elements</p>
                    <table class="styled-table" style="width:100%;">
                        <thead>
                            <tr>
                                <th>ID</th><th>Level</th><th>Cardinality</th><th>Business Term</th><th>Usage Note</th>
                                <th>Justification</th><th>Data Type</th><th>Type of Extension</th>
                                <th>Core Conformant /Rules broken</th><th>Included in Spec</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td colspan="10" style="text-align:center;">Please select a component from the dropdown.</td></tr>
                        </tbody>
                    </table>
                    <button onclick="document.getElementById('${sectionId}').remove(); isFormDirty=true; updateComponentSections();" class="view-button" style="margin-top: 10px; background: #dc3545;">Remove Selection</button>
                `;
                componentsContainer.appendChild(section);

                if (preSelectedComponentId) {
                    // Populate table immediately if a component is pre-selected
                    populateComponentTable(section.querySelector('.component-select'), preSelectedElementIds);
                }
            }

            // Function to handle removing sections and ensuring at least one remains
            function updateComponentSections() {
                const sections = document.querySelectorAll('.component-section');
                if (sections.length === 0) {
                    addNewComponentSection(); // Add a new empty section if all are removed
                }
            }

            // populateComponentTable now fetches elements for the selected component
            async function populateComponentTable(selectElement, selectedIds = []) {
                const selectedComponentId = selectElement.value;
                const tableBody = selectElement.closest('.component-section').querySelector('tbody');

                if (!selectedComponentId) {
                    tableBody.innerHTML = '<tr><td colspan="10" style="text-align:center;">Please select a component.</td></tr>';
                    return;
                }

                let componentElements = [];
                // Check cache first
                if (extensionComponentElementsCache[selectedComponentId]) {
                    componentElements = extensionComponentElementsCache[selectedComponentId];
                    console.log(`Loaded ${selectedComponentId} elements from cache.`);
                } else {
                    // Fetch elements for the selected component
                    const elementsApiUrl = `${AUTH_CONFIG.baseUrl}/extensionmodels/elements/${selectedComponentId}`;
                    console.log(`Fetching elements for component: ${elementsApiUrl}`);
                    try {
                        const elementsResponse = await authenticatedFetch(elementsApiUrl, {
                            method: 'GET',
                            forceAuth: true // This endpoint also requires authentication
                        });
                        if (!elementsResponse.ok) {
                            throw new Error(`HTTP error! status: ${elementsResponse.status}`);
                        }
                        const elementsData = await elementsResponse.json();
                        componentElements = Array.isArray(elementsData) ? elementsData : (elementsData.items || []); // Adjust based on API response structure
                        extensionComponentElementsCache[selectedComponentId] = componentElements; // Cache the fetched data
                        console.log(`Fetched ${componentElements.length} elements for ${selectedComponentId}.`);
                    } catch (error) {
                        console.error(`Error fetching elements for component ${selectedComponentId}:`, error);
                        tableBody.innerHTML = `<tr><td colspan="10" style="text-align:center; color:red;">Failed to load elements for this component.</td></tr>`;
                        return;
                    }
                }

                tableBody.innerHTML = ''; // Clear previous elements
                if (componentElements.length === 0) {
                     tableBody.innerHTML = `<tr><td colspan="10" style="text-align:center;">No elements found for this component.</td></tr>`;
                     return;
                }


                componentElements.forEach(el => {
                    const row = document.createElement('tr');
                    const isChecked = selectedIds.includes(el.id || el.ID); // Check against normalized ID

                    // Map properties from API response (assuming potential camelCase/PascalCase differences)
                    const mappedEl = {
                        ID: el.businessTermID || el.BusinessTermID || 'N/A',
                        Level: el.level || el.Level || 'N/A',
                        Cardinality: el.cardinality || el.Cardinality || 'N/A',
                        "Business Term": el.businessTerm || el.BusinessTerm || el['Business Term'] || 'N/A',
                        "Usage Note": el.semanticDescription || el.semanticDescription || el['Usage Note'] || 'N/A',
                        Justification: el.justification || el.Justification || 'N/A',
                        "Data Type": el.dataType || el.DataType || el['Data Type'] || 'N/A',
                        "Type of Extension": el.extensionType || el.ExtensionType || el['Type of Extension'] || 'N/A',
                        "Core Conformant/Rules broken": el.coreConformantRulesBroken || el.CoreConformantRulesBroken || el['Core Conformant/Rules broken'] || 'N/A'
                    };

                    row.innerHTML = `
                        <td>${mappedEl.ID}</td><td>${mappedEl.Level}</td><td>${mappedEl.Cardinality}</td>
                        <td>${mappedEl['Business Term']}<i class="fa-solid fa-circle-question" title="${mappedEl['Usage Note']}"></i></td>
                        <td>${mappedEl['Usage Note']}</td><td>${mappedEl.Justification}</td><td>${mappedEl['Data Type']}</td>
                        <td>${mappedEl['Type of Extension']}</td><td>${mappedEl['Core Conformant/Rules broken']}</td>
                        <td style="text-align:center;"><input type="checkbox" class="element-selector" data-id="${mappedEl.ID}" ${isChecked ? 'checked' : ''} onchange="isFormDirty=true;"></td>
                    `;
                    tableBody.appendChild(row);
                });
                isFormDirty = true; // Mark form as dirty after population
            }

            function handleSave(showAlert = true) {
                console.log('DEBUG: ExtensionComponentDataModel - handleSave called');
                
                const selectedExtensions = [];
                document.querySelectorAll('.component-section').forEach(section => {
                    const componentName = section.querySelector('.component-select').value;
                    if (componentName) {
                        const selectedElements = [];
                        section.querySelectorAll('.element-selector:checked').forEach(checkbox => {
                            selectedElements.push(checkbox.getAttribute('data-id'));
                        });
                        // Only save component sections that have selected elements OR if the component itself is selected (even if no elements are ticked for it)
                        // Adjust this logic if you want to save empty component selections
                        if (selectedElements.length > 0) { // Only save if at least one element is selected
                            selectedExtensions.push({ componentName, selectedElements });
                        }
                    }
                });

                console.log('DEBUG: ExtensionComponentDataModel - Selected extensions:', selectedExtensions);

                if (!dataManager) {
                    console.error('DEBUG: ExtensionComponentDataModel - Data manager not initialized');
                    alert("Error: Data manager not initialized.");
                    return;
                }

                try {
                    // Update the working data with selected extensions
                    if (!dataManager.workingData) {
                        dataManager.workingData = dataManager.loadWorkingDataFromLocalStorage() || {};
                    }
                    
                    dataManager.workingData.extensionComponentData = selectedExtensions;
                    
                    // Save to localStorage (working data)
                    dataManager.saveWorkingDataToLocalStorage();
                    
                    console.log('DEBUG: ExtensionComponentDataModel - Extension components saved to working data');
                    
                    if (showAlert) {
                        alert("Extension components saved!");
                    }
                    isFormDirty = false;
                } catch (error) {
                    console.error('DEBUG: ExtensionComponentDataModel - Error saving:', error);
                    alert("Error saving extension components: " + error.message);
                }
            }

            function handleCancel() {
                if (isFormDirty && !confirm("You have unsaved changes. Are you sure you want to cancel?")) {
                    return;
                }
                isFormDirty = false;
                
                // Use the proper return page logic
                const returnPage = localStorage.getItem("returnToPage") || "mySpecifications.html";
                console.log('DEBUG: ExtensionComponentDataModel - Returning to:', returnPage);
                window.location.href = returnPage;
            }

            function saveAndGoToNextStep() {
                handleSave(false);
                window.location.href = 'additionalRequirements.html';
            }

            document.addEventListener('DOMContentLoaded', async () => {
                console.log('DEBUG: ExtensionComponentDataModel - DOM loaded');
                
                componentsContainer = document.getElementById('components-container');
                
                // Initialize data manager and update title
                try {
                    await initializeDataManager();
                    
                    // Update title with specification name if available
                    const titleElement = document.querySelector('.page-Content h1');
                    if (titleElement && dataManager && dataManager.workingData && dataManager.workingData.specName) {
                        titleElement.innerHTML = `<i class="fa-solid fa-trailer"></i> Extension Component Data Model for: ${dataManager.workingData.specName}`;
                    }
                } catch (error) {
                    console.error('DEBUG: ExtensionComponentDataModel - Error in initialization:', error);
                }
                
                // Load extension data
                loadExtensionData(); // Initial load of components for dropdown

                // Listen for changes anywhere in the container to mark form dirty
                componentsContainer.addEventListener('change', () => { isFormDirty = true; });
            });

            window.addEventListener('beforeunload', (e) => {
                if (isFormDirty) {
                    e.preventDefault();
                    e.returnValue = '';
                }
            });
        </script>
        
        <script>
            // Initialize the sidebar and authentication when the page loads
            document.addEventListener('DOMContentLoaded', function() {
                // Initialize auth manager
                window.authManager.init();
                
                // Initialize sidebar
                window.sidebarManager.initializeSidebar(window.authManager);
            });
        </script>
    </body>
</html>