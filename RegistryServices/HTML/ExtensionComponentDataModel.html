<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
        <link rel="stylesheet" href="../CSS/style.css">
        
        <script src="../JS/javascript.js"></script>
        
        <title>Registry Services</title>
        <style>
            .component-section {
                border: 1px solid #ddd;
                padding: 15px;
                margin-bottom: 20px;
                background-color: #fff;
                border-radius: 5px;
            }
        </style>
    </head>
    <body>
        <div class="sidebar">
            <ul>
                <li>
                    <a class="logo">
                        <span class="icon">
                            <img src="../Images/genericLogo.png" alt="Sidebar Logo" style="width: 40px; height: 40px;">
                        </span>
                        <span class="text">Registry Services</span>
                    </a>
                </li>
                <li>
                    <a href="eInvoicingSpecificationRegistry.html">
                        <span class="icon"><i class="fa-solid fa-house"></i></span>
                        <span class="text">eInvoicing Specification Registry</span>
                    </a>
                </li>
                <li class="protected">
                    <a href="governingEntityList.html">
                        <span class="icon"><i class="fa-solid fa-building"></i></span>
                        <span class="text">Governing Entities</span>
                    </a>
                </li>
                <li class="protected">
                    <a href="mySpecifications.html">
                        <span class="icon"><i class="fa-solid fa-folder"></i></span>
                        <span class="text">My Specifications</span>
                    </a>
                </li>
                <li class="protected">
                    <a href="#">
                        <span class="icon"><i class="fa-solid fa-file-medical"></i></span>
                        <span class="text">Add New Specification</span>
                    </a>
                </li class="protected">
                <li class="child-element protected">
                    <a href="IdentifyingInformation.html">
                        <span class="icon"><i class="fa-solid fa-info"></i></span>
                        <span class="text">Identifying Information</span>
                    </a>
                </li>
                <li class="child-element">
                    <a href="coreInvoiceModel.html">
                        <span class="icon"><i class="fa-solid fa-car"></i></span>
                        <span class="text">Core Invoice Model</span>
                    </a>
                </li>
                <li class="child-element">
                    <a href="ExtensionComponentDataModel.html">
                        <span class="icon"><i class="fa-solid fa-trailer"></i></span>
                        <span class="text">Extension Component Data Model</span>
                    </a>
                </li>
                <li class="child-element protected">
                    <a href="additionalRequirements.html">
                        <span class="icon"><i class="fa-solid fa-circle-plus"></i></span>
                        <span class="text">Additional Requirements</span>
                    </a>
                </li>
                <li class="child-element protected">
                    <a href="SpecificationPreview.html">
                        <span class="icon"><i class="fa-solid fa-square-check"></i></span>
                        <span class="text">Specification Preview</span>
                    </a>
                </li>
                <li id="loginLogoutItem">
                    <a href="#" onclick="toggleLogin()">
                        <span class="icon"><i class="fa-solid fa-right-from-bracket"></i></span>
                        <span class="text" id="loginLogoutButton">Logout</span>
                    </a>
                </li>
            </ul>
        </div>

        <div class="page-Content">
            <h1><i class="fa-solid fa-trailer"></i> Extension Component Data Model</h1>
            <br/>
            
            <div id="components-container"></div>

            <button type="button" onclick="addNewComponentSection()" class="view-button" style="margin-top: 15px;">Add Another Extension Component</button>

            <hr style="margin: 30px 0;">

            <div style="display: flex; justify-content: space-between; gap: 10px; margin-top: 10px;">
                <div>
                    <button type="button" onclick="handleSave()" class="view-button" style="background:#ccc; color:#333;">Save</button>
                    <button type="button" onclick="handleCancel()" class="view-button" style="background-color: #F4A261; color: #fff;">Cancel</button>
                </div>
                <div>
                    <button type="button" onclick="saveAndGoToNextStep()" class="view-button" style="background:#217a36;">Additional Requirements</button>
                </div>
            </div>
        </div>

        <script>
            let isFormDirty = false;
            // Cache for storing fetched extension component elements to avoid re-fetching
            let extensionComponentElementsCache = {}; // Changed from extensionComponentData
            let componentsContainer;

            async function loadExtensionData() {
                try {
                    // Fetch the list of available Extension Components (headers)
                    // Assuming /api/extensionmodels/headers provides a list of {id, name} objects
                    const headersApiUrl = `${AUTH_CONFIG.baseUrl}/extensionmodels/headers?page=1&pageSize=50`; // Adjust page size as needed

                    console.log(`Attempting to fetch Extension Component Headers from API: ${headersApiUrl}`);
                    const headersResponse = await authenticatedFetch(headersApiUrl, {
                        method: 'GET',
                        forceAuth: true // Assuming this endpoint also requires authentication
                    });

                    if (!headersResponse.ok) {
                        throw new Error(`HTTP error! status: ${headersResponse.status}`);
                    }
                    const headersData = await headersResponse.json();
                    const availableComponents = headersData.items || headersData; // Assuming it returns {items: []} or directly an array
                    console.log('Available Extension Component Headers:', availableComponents);

                    // Populate the dropdown with available components
                    const initialSectionSelect = document.querySelector('.component-section .component-select');
                    if (initialSectionSelect) {
                        let options = '<option value="">Select an Extension Component</option>';
                        availableComponents.forEach(comp => {
                            options += `<option value="${comp.id}">${comp.name || comp.id}</option>`; // Use comp.name if available, else comp.id
                        });
                        initialSectionSelect.innerHTML = options;
                    }

                    // Pre-select any saved extensions when loading for editing
                    const editingSpecName = localStorage.getItem("selectedSpecification");
                    let savedExtensions = [];
                    if (editingSpecName) {
                        const specifications = JSON.parse(localStorage.getItem("specifications")) || [];
                        const specToEdit = specifications.find(spec => spec.specName === editingSpecName);
                        if (specToEdit && specToEdit.extensionComponents) {
                            savedExtensions = specToEdit.extensionComponents;
                        }
                    }

                    if (savedExtensions.length > 0) {
                        // For each saved extension, add a section and populate its table
                        for (const savedExt of savedExtensions) {
                            await addNewComponentSection(savedExt.componentName, savedExt.selectedElements);
                        }
                        // Remove the initial empty section if more than one saved extension was added
                        if (savedExtensions.length > 0 && document.querySelectorAll('.component-section').length > 1) {
                            document.querySelector('.component-section:first-child').remove();
                        }
                    } else {
                        // If no saved extensions, ensure at least one empty section is present
                        if (document.querySelectorAll('.component-section').length === 0) {
                            addNewComponentSection();
                        }
                    }

                } catch (error) {
                    console.error("Error loading extension component data:", error);
                    if (componentsContainer) {
                         componentsContainer.innerHTML = `<p style="color: red;">Error: Could not load extension component data. Please ensure you are logged in and the API is accessible.</p>`;
                    }
                }
            }

            // addNewComponentSection now takes an optional preSelectedComponentId and preSelectedElementIds
            async function addNewComponentSection(preSelectedComponentId = '', preSelectedElementIds = []) {
                const sectionId = `section-${Date.now()}`;
                const section = document.createElement('div');
                section.className = 'component-section';
                section.id = sectionId;

                // Fetch the list of all components again to populate the new dropdown
                const headersApiUrl = `${AUTH_CONFIG.baseUrl}/extensionmodels/headers?page=1&pageSize=50`;
                let availableComponents = [];
                try {
                    const headersResponse = await authenticatedFetch(headersApiUrl, { method: 'GET', forceAuth: true });
                    const headersData = await headersResponse.json();
                    availableComponents = headersData.items || headersData;
                } catch (error) {
                    console.error("Error re-fetching component headers for new section:", error);
                }

                let options = '<option value="">Select an Extension Component</option>';
                availableComponents.forEach(comp => {
                    options += `<option value="${comp.id}" ${comp.id === preSelectedComponentId ? 'selected' : ''}>${comp.name || comp.id}</option>`;
                });


                section.innerHTML = `
                    <select class="component-select" onchange="populateComponentTable(this, [])">${options}</select>
                    <p style="margin-top: 5px;">Select the required Extension Component and tick the box for all required elements</p>
                    <table class="styled-table" style="width:100%;">
                        <thead>
                            <tr>
                                <th>ID</th><th>Level</th><th>Cardinality</th><th>Business Term</th><th>Usage Note</th>
                                <th>Justification</th><th>Data Type</th><th>Type of Extension</th>
                                <th>Core Conformant /Rules broken</th><th>Included in Spec</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td colspan="10" style="text-align:center;">Please select a component from the dropdown.</td></tr>
                        </tbody>
                    </table>
                    <button onclick="document.getElementById('${sectionId}').remove(); isFormDirty=true; updateComponentSections();" class="view-button" style="margin-top: 10px; background: #dc3545;">Remove Selection</button>
                `;
                componentsContainer.appendChild(section);

                if (preSelectedComponentId) {
                    // Populate table immediately if a component is pre-selected
                    populateComponentTable(section.querySelector('.component-select'), preSelectedElementIds);
                }
            }

            // Function to handle removing sections and ensuring at least one remains
            function updateComponentSections() {
                const sections = document.querySelectorAll('.component-section');
                if (sections.length === 0) {
                    addNewComponentSection(); // Add a new empty section if all are removed
                }
            }

            // populateComponentTable now fetches elements for the selected component
            async function populateComponentTable(selectElement, selectedIds = []) {
                const selectedComponentId = selectElement.value;
                const tableBody = selectElement.closest('.component-section').querySelector('tbody');

                if (!selectedComponentId) {
                    tableBody.innerHTML = '<tr><td colspan="10" style="text-align:center;">Please select a component.</td></tr>';
                    return;
                }

                let componentElements = [];
                // Check cache first
                if (extensionComponentElementsCache[selectedComponentId]) {
                    componentElements = extensionComponentElementsCache[selectedComponentId];
                    console.log(`Loaded ${selectedComponentId} elements from cache.`);
                } else {
                    // Fetch elements for the selected component
                    const elementsApiUrl = `${AUTH_CONFIG.baseUrl}/extensionmodels/elements/${selectedComponentId}`;
                    console.log(`Fetching elements for component: ${elementsApiUrl}`);
                    try {
                        const elementsResponse = await authenticatedFetch(elementsApiUrl, {
                            method: 'GET',
                            forceAuth: true // This endpoint also requires authentication
                        });
                        if (!elementsResponse.ok) {
                            throw new Error(`HTTP error! status: ${elementsResponse.status}`);
                        }
                        const elementsData = await elementsResponse.json();
                        componentElements = Array.isArray(elementsData) ? elementsData : (elementsData.items || []); // Adjust based on API response structure
                        extensionComponentElementsCache[selectedComponentId] = componentElements; // Cache the fetched data
                        console.log(`Fetched ${componentElements.length} elements for ${selectedComponentId}.`);
                    } catch (error) {
                        console.error(`Error fetching elements for component ${selectedComponentId}:`, error);
                        tableBody.innerHTML = `<tr><td colspan="10" style="text-align:center; color:red;">Failed to load elements for this component.</td></tr>`;
                        return;
                    }
                }

                tableBody.innerHTML = ''; // Clear previous elements
                if (componentElements.length === 0) {
                     tableBody.innerHTML = `<tr><td colspan="10" style="text-align:center;">No elements found for this component.</td></tr>`;
                     return;
                }


                componentElements.forEach(el => {
                    const row = document.createElement('tr');
                    const isChecked = selectedIds.includes(el.id || el.ID); // Check against normalized ID

                    // Map properties from API response (assuming potential camelCase/PascalCase differences)
                    const mappedEl = {
                        ID: el.businessTermID || el.BusinessTermID || 'N/A',
                        Level: el.level || el.Level || 'N/A',
                        Cardinality: el.cardinality || el.Cardinality || 'N/A',
                        "Business Term": el.businessTerm || el.BusinessTerm || el['Business Term'] || 'N/A',
                        "Usage Note": el.semanticDescription || el.semanticDescription || el['Usage Note'] || 'N/A',
                        Justification: el.justification || el.Justification || 'N/A',
                        "Data Type": el.dataType || el.DataType || el['Data Type'] || 'N/A',
                        "Type of Extension": el.extensionType || el.ExtensionType || el['Type of Extension'] || 'N/A',
                        "Core Conformant/Rules broken": el.coreConformantRulesBroken || el.CoreConformantRulesBroken || el['Core Conformant/Rules broken'] || 'N/A'
                    };

                    row.innerHTML = `
                        <td>${mappedEl.ID}</td><td>${mappedEl.Level}</td><td>${mappedEl.Cardinality}</td>
                        <td>${mappedEl['Business Term']}<i class="fa-solid fa-circle-question" title="${mappedEl['Usage Note']}"></i></td>
                        <td>${mappedEl['Usage Note']}</td><td>${mappedEl.Justification}</td><td>${mappedEl['Data Type']}</td>
                        <td>${mappedEl['Type of Extension']}</td><td>${mappedEl['Core Conformant/Rules broken']}</td>
                        <td style="text-align:center;"><input type="checkbox" class="element-selector" data-id="${mappedEl.ID}" ${isChecked ? 'checked' : ''} onchange="isFormDirty=true;"></td>
                    `;
                    tableBody.appendChild(row);
                });
                isFormDirty = true; // Mark form as dirty after population
            }

            function handleSave(showAlert = true) {
                const selectedExtensions = [];
                document.querySelectorAll('.component-section').forEach(section => {
                    const componentName = section.querySelector('.component-select').value;
                    if (componentName) {
                        const selectedElements = [];
                        section.querySelectorAll('.element-selector:checked').forEach(checkbox => {
                            selectedElements.push(checkbox.getAttribute('data-id'));
                        });
                        // Only save component sections that have selected elements OR if the component itself is selected (even if no elements are ticked for it)
                        // Adjust this logic if you want to save empty component selections
                        if (selectedElements.length > 0) { // Only save if at least one element is selected
                            selectedExtensions.push({ componentName, selectedElements });
                        }
                    }
                });

                const editingSpecName = localStorage.getItem("selectedSpecification");
                if (!editingSpecName) { alert("Error: No specification selected."); return; }

                let specifications = JSON.parse(localStorage.getItem("specifications")) || [];
                const specIndex = specifications.findIndex(spec => spec.specName === editingSpecName);

                if (specIndex > -1) {
                    specifications[specIndex].extensionComponents = selectedExtensions;
                    localStorage.setItem('specifications', JSON.stringify(specifications));
                    if (showAlert) alert("Extension components saved!");
                    isFormDirty = false;
                } else {
                    alert("Error: Could not find the specification to save to.");
                }
            }

            function handleCancel() {
                if (isFormDirty && !confirm("You have unsaved changes. Are you sure you want to cancel?")) {
                    return;
                }
                isFormDirty = false;
                window.location.href = 'mySpecifications.html';
            }

            function saveAndGoToNextStep() {
                handleSave(false);
                window.location.href = 'additionalRequirements.html';
            }

            document.addEventListener('DOMContentLoaded', () => {
                const titleElement = document.querySelector('.page-Content h1');
                const editingSpecName = localStorage.getItem("selectedSpecification");
                if (titleElement && editingSpecName) {
                    titleElement.innerHTML = `<i class="fa-solid fa-trailer"></i> Extension Component Data Model for: ${editingSpecName}`;
                }

                componentsContainer = document.getElementById('components-container');
                loadExtensionData(); // Initial load of components for dropdown

                // Listen for changes anywhere in the container to mark form dirty
                componentsContainer.addEventListener('change', () => { isFormDirty = true; });
            });

            window.addEventListener('beforeunload', (e) => {
                if (isFormDirty) {
                    e.preventDefault();
                    e.returnValue = '';
                }
            });
        </script>
    </body>
</html>