<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
        <link rel="stylesheet" href="../CSS/style.css">
        <!-- Remove inline AUTH_CONFIG, use the one from authManager.js -->
        <script src="../JS/auth/authManager.js"></script>
        <script>
            // Create a global authManager instance
            window.authManager = new AuthManager();
            // Define authenticatedFetch globally
            function authenticatedFetch(url, options = {}) {
                const headers = { ...(options.headers || {}), ...window.authManager.getAuthHeaders() };
                return fetch(url, { ...options, headers });
            }
        </script>
        <script src="../JS/sidebarManager.js"></script>
        <script src="../JS/javascript.js"></script>
        <script src="../JS/dataManager.js"></script>
        
        <title>Registry Services</title>
    </head>
    <body>
<!----------------------------------------------------------------------------
        Sidebar
  ------------------------------------------------------------------------------>
        <div id="sidebarContainer">
            <!-- Sidebar will be dynamically generated by sidebarManager.js -->
        </div>

<!----------------------------------------------------------------------------
        Main Content
  ------------------------------------------------------------------------------>
        <div class="page-Content">
            <h1>
                <i class="fa-solid fa-trailer"></i> Extension Component Data Model
                <span style="color: #b22222; font-size: 0.6em; margin-left: 12px; vertical-align: middle;">(READ-ONLY)</span>
            </h1>
            <br/>
            <span><b>Select the required Extension Component and view its required elements</b></span>
            <br/><br/>

            <div id="components-container"></div>

            <button id="addAnotherComponentBtn" type="button" onclick="addNewComponentSection()" class="view-button" style="margin-top: 15px;">Add Another Extension Component</button>

            <hr style="margin: 30px 0;">

            <div style="display: flex; justify-content: space-between; gap: 10px; margin-top: 10px;">
                <div>
                    <button id="saveBtn" type="button" onclick="handleSave()" class="view-button" style="background:#ccc; color:#333;">Save</button>
                    <button id="cancelBtn" type="button" onclick="handleCancel()" class="view-button" style="background-color: #F4A261; color: #fff;">Cancel New Specification</button>
                </div>
                <div>
                    <button id="nextStepBtn" type="button" onclick="saveAndGoToNextStep()" class="view-button" style="background:#217a36;">Additional Requirements</button>
                </div>
            </div>

            <br/>
        </div>

<!----------------------------------------------------------------------------
        Javascript for the table
  ------------------------------------------------------------------------------>
        <script>
            // *** START OF READ-ONLY FLAG ***
            window.isExtensionReadOnly = true; // Set this page to read-only
            // *** END OF READ-ONLY FLAG ***

            let isFormDirty = false;
            let dataManager = null;
            let extensionComponentElementsCache = {};
            let componentsContainer;


            function getNumericLevelFromDotNotation(levelStr) {
                if (!levelStr) return 0;
                if (levelStr.includes('+')) {
                return levelStr.split('+').length - 1;
                }
                const parts = levelStr.split('.');
                if (parts.length === 1 && !isNaN(parseInt(parts[0]))) {
                return 1; 
                }
                return parts.length > 0 ? parts.length : 0;
            }
            
            // Initialize data manager for read-only mode
            async function initializeDataManager() {
                try {
                    console.log('DEBUG: ExtensionComponentDataModelRead - Initializing data manager');
                    
                    dataManager = new SpecificationDataManager();
                    console.log('DEBUG: ExtensionComponentDataModelRead - Data manager initialized');
                    console.log('DEBUG: ExtensionComponentDataModelRead - Mode:', dataManager.currentMode);
                    
                    if (dataManager.isEditMode() && dataManager.currentSpecId) {
                        console.log('DEBUG: ExtensionComponentDataModelRead - Loading specification for reading. ID:', dataManager.currentSpecId);
                        
                        // Load data from API if not already loaded
                        if (!dataManager.isDataLoaded) {
                            await dataManager.loadSpecificationFromAPI(dataManager.currentSpecId);
                        }
                        
                        const workingData = dataManager.workingData || dataManager.loadWorkingDataFromLocalStorage();
                        if (workingData && workingData.extensionComponentData) {
                            console.log('DEBUG: ExtensionComponentDataModelRead - Found extension component data:', workingData.extensionComponentData);
                            return workingData.extensionComponentData;
                        }
                    }
                    
                    console.log('DEBUG: ExtensionComponentDataModelRead - No existing extension data found');
                    return [];
                } catch (error) {
                    console.error('DEBUG: ExtensionComponentDataModelRead - Error initializing data manager:', error);
                    return [];
                }
            }

            async function loadExtensionData() {
                try {
                    const headersApiUrl = `${AUTH_CONFIG.baseUrl}/extensionmodels/headers?page=1&pageSize=50`;

                    console.log(`Attempting to fetch Extension Component Headers from API: ${headersApiUrl}`);
                    const headersResponse = await authenticatedFetch(headersApiUrl, {
                        method: 'GET',
                        forceAuth: true
                    });

                    if (!headersResponse.ok) {
                        throw new Error(`HTTP error! status: ${headersResponse.status}`);
                    }
                    const headersData = await headersResponse.json();
                    const availableComponents = headersData.items || headersData;
                    console.log('Available Extension Component Headers:', availableComponents);

                    const initialSectionSelect = document.querySelector('.component-section .component-select');
                    if (initialSectionSelect) {
                        let options = '<option value="">Select an Extension Component</option>';
                        availableComponents.forEach(comp => {
                            options += `<option value="${comp.id}" ${comp.id === initialSectionSelect.value ? 'selected' : ''}>${comp.name || comp.id}</option>`;
                        });
                        initialSectionSelect.innerHTML = options;
                    }

                    const editingSpecName = localStorage.getItem("selectedSpecification");
                    // Initialize data manager first and get saved extensions
                    const savedExtensions = await initializeDataManager();
                    
                    // Use saved extensions from data manager instead of localStorage
                    if (savedExtensions && savedExtensions.length > 0) {
                        console.log('DEBUG: ExtensionComponentDataModelRead - Loading saved extensions:', savedExtensions);
                        for (const savedExt of savedExtensions) {
                            await addNewComponentSection(savedExt.componentName, savedExt.selectedElements);
                        }
                        if (savedExtensions.length > 0 && document.querySelectorAll('.component-section').length > 1) {
                            document.querySelector('.component-section:first-child').remove();
                        }
                    } else {
                        if (document.querySelectorAll('.component-section').length === 0) {
                            addNewComponentSection();
                        }
                    }

                } catch (error) {
                    console.error("Error loading extension component data:", error);
                    if (componentsContainer) {
                         componentsContainer.innerHTML = `<p style="color: red;">Error: Could not load extension component data. Please ensure you are logged in and the API is accessible.</p>`;
                    }
                }
                applyReadOnlyMode(); // Apply read-only after content is loaded
            }

            async function addNewComponentSection(preSelectedComponentId = '', preSelectedElementIds = []) {
                const sectionId = `section-${Date.now()}`;
                const section = document.createElement('div');
                section.className = 'component-section';
                section.id = sectionId;

                const headersApiUrl = `${AUTH_CONFIG.baseUrl}/extensionmodels/headers?page=1&pageSize=50`;
                let availableComponents = [];
                try {
                    const headersResponse = await authenticatedFetch(headersApiUrl, { method: 'GET', forceAuth: true });
                    const headersData = await headersResponse.json();
                    availableComponents = headersData.items || headersData;
                } catch (error) {
                    console.error("Error re-fetching component headers for new section:", error);
                }

                let options = '<option value="">Select an Extension Component</option>';
                availableComponents.forEach(comp => {
                    options += `<option value="${comp.id}" ${comp.id === preSelectedComponentId ? 'selected' : ''}>${comp.name || comp.id}</option>`;
                });

                section.innerHTML = `
                    <select class="component-select">${options}</select>
                    <p style="margin-top: 5px;">Select the required Extension Component and tick the box for all required elements</p>
                    <table class="styled-table" style="width:100%;">
                        <thead>
                            <tr>
                                <th>ID</th><th>Level</th><th>Cardinality</th><th>Business Term</th><th>Usage Note</th>
                                <th>Justification</th><th>Data Type</th><th>Type of Extension</th>
                                <th>Core Conformant /Rules broken</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td colspan="9" style="text-align:center;">Please select a component from the dropdown.</td></tr>
                        </tbody>
                    </table>
                    <button onclick="document.getElementById('${sectionId}').remove(); isFormDirty=true; updateComponentSections();" class="view-button remove-section-btn" style="margin-top: 10px; background: #dc3545;">Remove Selection</button>
                `;
                componentsContainer.appendChild(section);

                // Add event listener for dropdown change
                const select = section.querySelector('.component-select');
                select.addEventListener('change', function() {
                    populateComponentTable(this, []);
                });
                // Ensure the dropdown is enabled (not disabled)
                select.disabled = false;

                if (preSelectedComponentId) {
                    populateComponentTable(section.querySelector('.component-select'), preSelectedElementIds);
                }
                applyReadOnlyMode(); // Apply read-only mode to newly added section
            }

            function updateComponentSections() {
                const sections = document.querySelectorAll('.component-section');
                if (sections.length === 0) {
                    addNewComponentSection();
                }
                applyReadOnlyMode(); // Re-apply read-only mode after section removal/addition
            }

            // Remove the read-only check from populateComponentTable so the dropdown always works
            async function populateComponentTable(selectElement, selectedIds = []) {
                const selectedComponentId = selectElement.value;
                const tableBody = selectElement.closest('.component-section').querySelector('tbody');

                if (!selectedComponentId) {
                    tableBody.innerHTML = '<tr><td colspan="9" style="text-align:center;">Please select a component.</td></tr>';
                    return;
                }

                let componentElements = [];
                if (extensionComponentElementsCache[selectedComponentId]) {
                    componentElements = extensionComponentElementsCache[selectedComponentId];
                    console.log(`Loaded ${selectedComponentId} elements from cache.`);
                } else {
                    const elementsApiUrl = `${AUTH_CONFIG.baseUrl}/extensionmodels/elements/${selectedComponentId}`;
                    console.log(`Fetching elements for component: ${elementsApiUrl}`);
                    try {
                        const elementsResponse = await authenticatedFetch(elementsApiUrl, {
                            method: 'GET',
                            forceAuth: true
                        });
                        if (!elementsResponse.ok) {
                            throw new Error(`HTTP error! status: ${elementsResponse.status}`);
                        }
                        const elementsData = await elementsResponse.json();
                        // Updated: No more pagination, response is directly an array
                        componentElements = Array.isArray(elementsData) ? elementsData : [];
                        extensionComponentElementsCache[selectedComponentId] = componentElements;
                        console.log(`Fetched ${componentElements.length} elements for ${selectedComponentId}.`);
                    } catch (error) {
                        console.error(`Error fetching elements for component ${selectedComponentId}:`, error);
                        tableBody.innerHTML = `<tr><td colspan="9" style="text-align:center; color:red;">Failed to load elements for this component.</td></tr>`;
                        return;
                    }
                }

                tableBody.innerHTML = '';
                if (componentElements.length === 0) {
                     tableBody.innerHTML = `<tr><td colspan="9" style="text-align:center;">No elements found for this component.</td></tr>`;
                     return;
                }

                componentElements.forEach(el => {
                    const row = document.createElement('tr');
                    const businessTermID = el.businessTermID || el.BusinessTermID || el.id || el.ID;
                    const isChecked = selectedIds.includes(el.businessTermID);

                    const isXG = businessTermID.startsWith('XG');
                    const isXT = businessTermID.startsWith('XT');
                    const isBG = businessTermID.startsWith('BG'); // Check for BG
                    const numericLevel = getNumericLevelFromDotNotation(el.level || '');
                    
                    if (isXG) {
                if (numericLevel === 1) { // Interpretation of 'LEVEL 1 parent' for XG
                    row.classList.add('level-1-xg');
                } else if (numericLevel === 2 || numericLevel === 3) { // Interpretation of 'LEVEL 2 or 3 parent' for XG
                    row.classList.add('level-2-xg'); // Assuming level-3-xg is same as level-2-xg for now
                }
                // XG elements are typically parents or nested within an XG hierarchy,
                // apply parent/child classes if they have children or are part of a structure
                // (You may need to enhance this based on actual XG data structure if it has nesting)
                if (numericLevel === 1) { // Assuming level 1 XG is a main parent
                    row.classList.add('parent-row');
                } else if (numericLevel > 1) { // Assuming other levels are children
                    row.classList.add('child-row');
                }

            } else if (isXT) {
                row.classList.add('level-xt');
                // XT elements are typically not parents themselves, but are children.
                // Apply child-row if their level implies nesting.
                if (numericLevel > 0) { // If it has any level, it's a child of something
                    row.classList.add('child-row');
                }
            } else if (isBG) { // Apply green coloring for BG elements
                if (numericLevel === 1) { // Dark green for LEVEL 1 BG parents
                    row.classList.add('level-1-bg');
                    row.classList.add('parent-row'); // Add parent-row for level 1 BG
                } else if (numericLevel === 2 || numericLevel === 3) { // Medium green for LEVEL 2 or 3 BG parents
                    row.classList.add('level-2-bg'); // Use level-2-bg for both 2 and 3
                    row.classList.add('child-row'); // Add child-row for nested BG elements
                }
                // If it's a BG element but not a recognized parent level, it will fall through to default table styling
            }
                    const mappedEl = {
                        ID: el.businessTermID || 'N/A',
                        Level: el.level || 'N/A',
                        Cardinality: el.cardinality || 'N/A',
                        "Business Term": el.businessTerm || 'N/A',
                        "Usage Note": el.usageNoteExtension || 'N/A',
                        Justification: el.justification || 'N/A',
                        "Data Type": el.dataType || 'N/A',
                        "Type of Extension": el.extensionType || 'N/A',
                        "Core Conformant/Rules broken": el.conformanceType || 'N/A'
                    };

                    row.innerHTML = `
                        <td>${mappedEl.ID}</td><td>${mappedEl.Level}</td><td>${mappedEl.Cardinality}</td>
                        <td>${mappedEl["Business Term"]}<i class="fa-solid fa-circle-question" title="${mappedEl['Usage Note']}"></i></td>  <td>${mappedEl['Usage Note']}</td><td>${mappedEl.Justification}</td><td>${mappedEl['Data Type']}</td>
                        <td>${mappedEl['Type of Extension']}</td><td>${mappedEl['Core Conformant/Rules broken']}</td>
                    `;
                    tableBody.appendChild(row);
                });
                isFormDirty = true;
                applyReadOnlyMode(); // Apply read-only mode to newly populated table
            }

            function handleSave(showAlert = true) {
                const selectedExtensions = [];
                document.querySelectorAll('.component-section').forEach(section => {
                    const componentName = section.querySelector('.component-select').value;
                    if (componentName) {
                        const selectedElements = [];
                        section.querySelectorAll('.element-selector:checked').forEach(checkbox => {
                            selectedElements.push(checkbox.getAttribute('data-id'));
                        });
                        if (selectedElements.length > 0) {
                            selectedExtensions.push({ componentName, selectedElements });
                        }
                    }
                });

                const editingSpecName = localStorage.getItem("selectedSpecification");
                if (!editingSpecName) { alert("Error: No specification selected."); return; }

                let specifications = JSON.parse(localStorage.getItem("specifications")) || [];
                const specIndex = specifications.findIndex(spec => spec.specName === editingSpecName);

                if (specIndex > -1) {
                    specifications[specIndex].extensionComponents = selectedExtensions;
                    localStorage.setItem('specifications', JSON.stringify(specifications));
                    if (showAlert) alert("Extension components saved!");
                    isFormDirty = false;
                } else {
                    alert("Error: Could not find the specification to save to.");
                }
            }

            function handleCancel() {
                if (isFormDirty && !confirm("You have unsaved changes. Are you sure you want to cancel?")) {
                    return;
                }
                isFormDirty = false;
                window.location.href = 'mySpecifications.html';
            }

            function saveAndGoToNextStep() {
                handleSave(false);
                window.location.href = 'additionalRequirements.html';
            }

            // Function to apply read-only state to all relevant elements
            function applyReadOnlyMode() {
                if (window.isExtensionReadOnly) {
                    // Do NOT disable select dropdowns so user can always change/view components
                    // Disable all checkboxes
                    document.querySelectorAll('.element-selector').forEach(checkbox => checkbox.disabled = true);
                    // Hide/disable action buttons
                    document.getElementById('addAnotherComponentBtn').style.display = 'none';
                    document.getElementById('saveBtn').style.display = 'none';
                    document.getElementById('cancelBtn').style.display = 'none';
                    document.getElementById('nextStepBtn').style.display = 'none';
                    // Hide remove section buttons
                    document.querySelectorAll('.remove-section-btn').forEach(btn => btn.style.display = 'none');
                    isFormDirty = false; // Cannot have unsaved changes in read-only mode
                }
            }

            document.addEventListener("DOMContentLoaded", () => {
                componentsContainer = document.getElementById('components-container');
                loadExtensionData(); // Initial load of components for dropdown

                const titleElement = document.querySelector('.page-Content h1');
                // For read-only mode, always show the simple title without specification name
                if (titleElement && window.isExtensionReadOnly) {
                    titleElement.innerHTML = `<i class="fa-solid fa-trailer"></i> Extension Component Data Model <span style="color: #b22222; font-size: 0.6em; margin-left: 12px; vertical-align: middle;">(READ-ONLY)</span>`;
                }

                componentsContainer.addEventListener('change', () => { isFormDirty = true; });
                
                // Ensure read-only mode is applied on initial load if the flag is set
                // This call moved to loadExtensionData() and addNewComponentSection() for dynamic content
                // but keep here for initial static elements like buttons.
                applyReadOnlyMode();
            });

            window.addEventListener('beforeunload', (e) => {
                if (isFormDirty && !window.isExtensionReadOnly) { // Only prompt if not read-only
                    e.preventDefault();
                    e.returnValue = '';
                }
            });
        </script>
        <style>
        /* Add this style for row highlighting */
        .selected-row {
            background-color: #d0e7ff !important;
        }
        
        </style>
        
        <script>
            // Initialize the sidebar and authentication when the page loads
            document.addEventListener('DOMContentLoaded', function() {
                // Initialize auth manager
                window.authManager.init();
                
                // Initialize sidebar
                window.sidebarManager.initializeSidebar(window.authManager);
            });
        </script>
    </body>
</html>